package goerr

import (
	"fmt"
	"io"
	"path"
	"runtime"
	"strconv"
	"strings"
)

// Stack represents function, file and line No of stack trace
type Stack struct {
	Func string `json:"func"`
	File string `json:"file"`
	Line int    `json:"line"`
}

// Stacks returns stack trace array generated by pkg/errors
func (x *Error) Stacks() []*Stack {
	if x.st == nil {
		return nil
	}

	stacks := make([]*Stack, 0, len(*x.st))
	for _, pc := range *x.st {
		f := newFrame(pc)
		stacks = append(stacks, &Stack{
			Func: f.getFunctionName(),
			File: f.getFilePath(),
			Line: f.getLineNumber(),
		})
	}
	return stacks
}

// StackTrace returns stack trace that is compatible with pkg/errors
func (x *Error) StackTrace() StackTrace {
	if x.st == nil {
		return nil
	}
	return x.st.toStackTrace()
}

// frame represents a single stack frame
type frame uintptr

// stack represents a stack of program counters
type stack []uintptr

// StackTrace is array of frame. It's exported for compatibility with github.com/pkg/errors
type StackTrace []frame

// newFrame creates a new frame from program counter
func newFrame(pc uintptr) frame {
	return frame(pc - 1)
}

// pc returns the program counter for this frame
func (f frame) pc() uintptr {
	return uintptr(f)
}

// getFilePath returns the full path to the file that contains the function
func (f frame) getFilePath() string {
	fn := runtime.FuncForPC(f.pc())
	if fn == nil {
		return "unknown"
	}
	file, _ := fn.FileLine(f.pc())
	return file
}

// getLineNumber returns the line number of source code
func (f frame) getLineNumber() int {
	fn := runtime.FuncForPC(f.pc())
	if fn == nil {
		return 0
	}
	_, line := fn.FileLine(f.pc())
	return line
}

// getFunctionName returns the name of this function
func (f frame) getFunctionName() string {
	fn := runtime.FuncForPC(f.pc())
	if fn == nil {
		return "unknown"
	}
	return fn.Name()
}

// Format implements fmt.Formatter interface
func (f frame) Format(s fmt.State, verb rune) {
	switch verb {
	case 's':
		if s.Flag('+') {
			f.formatWithFunctionName(s)
		} else {
			f.formatBaseFileName(s)
		}
	case 'd':
		f.formatLineNumber(s)
	case 'n':
		f.formatShortFunctionName(s)
	case 'v':
		f.formatVerbose(s)
	}
}

func (f frame) formatWithFunctionName(s fmt.State) {
	_, _ = io.WriteString(s, f.getFunctionName())
	_, _ = io.WriteString(s, "\n\t")
	_, _ = io.WriteString(s, f.getFilePath())
}

func (f frame) formatBaseFileName(s fmt.State) {
	_, _ = io.WriteString(s, path.Base(f.getFilePath()))
}

func (f frame) formatLineNumber(s fmt.State) {
	_, _ = io.WriteString(s, strconv.Itoa(f.getLineNumber()))
}

func (f frame) formatShortFunctionName(s fmt.State) {
	_, _ = io.WriteString(s, getShortFunctionName(f.getFunctionName()))
}

func (f frame) formatVerbose(s fmt.State) {
	f.Format(s, 's')
	_, _ = io.WriteString(s, ":")
	f.Format(s, 'd')
}

// MarshalText implements encoding.TextMarshaler interface
func (f frame) MarshalText() ([]byte, error) {
	name := f.getFunctionName()
	if name == "unknown" {
		return []byte(name), nil
	}
	return []byte(fmt.Sprintf("%s %s:%d", name, f.getFilePath(), f.getLineNumber())), nil
}

// Format implements fmt.Formatter interface for StackTrace
func (st StackTrace) Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		if s.Flag('+') {
			st.formatVerbose(s)
		} else if s.Flag('#') {
			st.formatGoSyntax(s)
		} else {
			st.formatSlice(s, verb)
		}
	case 's':
		st.formatSlice(s, verb)
	}
}

func (st StackTrace) formatVerbose(s fmt.State) {
	for _, f := range st {
		_, _ = io.WriteString(s, "\n")
		f.Format(s, 'v')
	}
}

func (st StackTrace) formatGoSyntax(s fmt.State) {
	fmt.Fprintf(s, "%#v", []frame(st))
}

func (st StackTrace) formatSlice(s fmt.State, verb rune) {
	_, _ = io.WriteString(s, "[")
	for i, f := range st {
		if i > 0 {
			_, _ = io.WriteString(s, " ")
		}
		f.Format(s, verb)
	}
	_, _ = io.WriteString(s, "]")
}

// Format implements fmt.Formatter interface for stack
func (s *stack) Format(st fmt.State, verb rune) {
	if verb == 'v' && st.Flag('+') {
		for _, pc := range *s {
			f := newFrame(pc)
			fmt.Fprintf(st, "\n%+v", f)
		}
	}
}

// toStackTrace converts stack to StackTrace
func (s *stack) toStackTrace() StackTrace {
	if s == nil {
		return nil
	}
	frames := make([]frame, len(*s))
	for i, pc := range *s {
		frames[i] = newFrame(pc)
	}
	return frames
}

// unstack trims the stack trace by n frames
func unstack(st *stack, n int) *stack {
	if st == nil {
		return &stack{}
	}

	switch {
	case n <= 0:
		return &stack{}
	case n >= len(*st):
		return st
	default:
		trimmed := (*st)[n:]
		return &trimmed
	}
}

// callers returns the stack of program counters
func callers() *stack {
	const depth = 32
	var pcs [depth]uintptr
	n := runtime.Callers(4, pcs[:])
	st := stack(pcs[:n])
	return &st
}

// getShortFunctionName removes the path prefix component of a function's name
func getShortFunctionName(name string) string {
	parts := strings.Split(name, "/")
	lastPart := parts[len(parts)-1]
	dotIndex := strings.Index(lastPart, ".")
	if dotIndex == -1 {
		return lastPart
	}
	return lastPart[dotIndex+1:]
}
